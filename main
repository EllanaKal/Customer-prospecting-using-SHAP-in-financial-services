

### **`shap_customer_prospecting.ipynb` (Core Code)**

```python
# --- Customer Prospecting using SHAP ---
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, roc_auc_score
from xgboost import XGBClassifier
import shap
import matplotlib.pyplot as plt

# --- 1. Generate Synthetic Data ---
np.random.seed(42)
n = 1000
df = pd.DataFrame({
    'Age': np.random.randint(18, 70, n),
    'Tenure': np.random.randint(1, 15, n),
    'Credit_Score': np.random.randint(400, 850, n),
    'Avg_Balance': np.random.randint(1000, 50000, n),
    'Digital_Engagement': np.random.randint(1, 60, n),
    'Previous_Purchase': np.random.randint(0, 2, n),
    'Income': np.random.randint(30000, 150000, n)
})

# Simulated target: more digital engagement + balance â†’ higher probability
df['Bought_Digital_Product'] = (
    (df['Digital_Engagement'] * 0.03 + df['Previous_Purchase'] * 0.5 +
     df['Avg_Balance'] / 50000 + np.random.randn(n) * 0.1) > 1
).astype(int)

# --- 2. Split Data ---
X = df.drop('Bought_Digital_Product', axis=1)
y = df['Bought_Digital_Product']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# --- 3. Train Model ---
model = XGBClassifier(max_depth=4, learning_rate=0.1, n_estimators=100)
model.fit(X_train, y_train)

# --- 4. Evaluate ---
preds = model.predict(X_test)
auc = roc_auc_score(y_test, model.predict_proba(X_test)[:,1])
print(f"Accuracy: {accuracy_score(y_test, preds):.2f}")
print(f"AUC: {auc:.2f}")

# --- 5. Explain with SHAP ---
explainer = shap.Explainer(model, X_train)
shap_values = explainer(X_test)

# Global Explanation
shap.summary_plot(shap_values, X_test)
plt.savefig('images/shap_summary.png', bbox_inches='tight')

# Individual Prediction Explanation
idx = 5
shap.plots.waterfall(shap_values[idx])
plt.savefig('images/shap_waterfall.png', bbox_inches='tight')

# --- 6. Insights ---
print("\nTop SHAP Features (mean |value|):")
print(pd.DataFrame({
    "Feature": X_test.columns,
    "SHAP_Importance": np.abs(shap_values.values).mean(axis=0)
}).sort_values(by="SHAP_Importance", ascending=False)
